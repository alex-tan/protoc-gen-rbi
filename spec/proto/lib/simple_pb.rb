# Code generated by protoc-gen-rbi. DO NOT EDIT.
# source: simple.proto
# typed: strict

module SimplePb
end


module PbHelper
  extend T::Sig

  sig {
    params(value: T.untyped, defaultValue: T.untyped).returns(T.untyped)
  }
  def self.withDefault(value, defaultValue)
    value.nil? ? defaultValue : value
  end

  sig {
    params(value: T.untyped, blk: T.proc.params(v: T.untyped).returns(T.untyped)).returns(T.untyped)
  }
  def self.mapNil(value, &blk)
    value.nil? ? nil : blk.call(value)
  end
end


class SimplePb::Colour < T::Enum
  extend T::Sig

  enums do
    Red = new("RED")
    Green = new("GREEN")
    Blue = new("BLUE")
  end

  class Attr < EnumAttrBase
    sig { override.params(value: T.untyped).returns(T.nilable(SimplePb::Colour)) }
    def deserialize(value)
      SimplePb::Colour.deserialize(value) unless value.nil?
    end
  end

  sig { returns(String) }
  def to_s
    serialize
  end
end


# T::Structs require forward declarations of reference classes
# dynamically declaring them like this hides the duplicate 
# declaration from sorbet, and keeps ruby happy about 
# classes existing before they're referenced
SimplePb::Empty = Class.new(T::Struct)
SimplePb::Simple = Class.new(T::Struct)
SimplePb::Foo = Class.new(T::Struct)



class SimplePb::Empty < T::Struct
  extend T::Sig
  include T::Props::Serializable
  include T::Struct::ActsAsComparable

  sig { returns(String) }
  def to_json
    serialize.to_json
  end

  sig { params(_strict: T::Boolean).returns(T::Hash[String, T.untyped]) }
  def serialize(_strict = true)
    serialize_result = { 
    }
    serialize_result
  end

  sig { params(contents: String).returns(SimplePb::Empty) }
  def self.decode_json(contents)
    json_obj = JSON.parse(contents)
    from_hash(json_obj)
  end

  sig { params(hash: T::Hash[String, T.untyped]).returns(SimplePb::Empty) }
  def self.from_hash(hash)
    new(
    )
  end
end


class SimplePb::Simple < T::Struct
  extend T::Sig
  include T::Props::Serializable
  include T::Struct::ActsAsComparable

  const :int32_field, Integer

  sig { returns(String) }
  def to_json
    serialize.to_json
  end

  sig { params(_strict: T::Boolean).returns(T::Hash[String, T.untyped]) }
  def serialize(_strict = true)
    serialize_result = { 
      "int32Field": int32_field,
    }
    serialize_result
  end

  sig { params(contents: String).returns(SimplePb::Simple) }
  def self.decode_json(contents)
    json_obj = JSON.parse(contents)
    from_hash(json_obj)
  end

  sig { params(hash: T::Hash[String, T.untyped]).returns(SimplePb::Simple) }
  def self.from_hash(hash)
    new(
      int32_field: (PbHelper::withDefault(hash["int32Field"], 0)),
    )
  end
end


class SimplePb::Foo < T::Struct
  extend T::Sig
  include T::Props::Serializable
  include T::Struct::ActsAsComparable

  const :s, SimplePb::Simple

  const :ss, T::Array[SimplePb::Simple]

  const :optional_s, T.nilable(SimplePb::Simple)

  const :colour, SimplePb::Colour

  const :colours, T::Array[SimplePb::Colour]

  const :optional_colour, T.nilable(SimplePb::Colour)

  const :int_field, Integer

  const :int_fields, T::Array[Integer]

  const :optional_int_field, T.nilable(Integer)

  const :int64_field, Integer

  const :int64_fields, T::Array[Integer]

  const :optional_int64_field, T.nilable(Integer)

  const :timestamp_field, Time

  const :timestamp_fields, T::Array[Time]

  const :optional_timestamp_field, T.nilable(Time)

  module Oo; end
  const :oo, Oo

  module Oo
    extend T::Sig
    extend T::Helpers
    include T::Props::Serializable
    sealed!

    sig { params(_strict: T::Boolean).returns(T::Hash[String, T.untyped]) }
    def serialize(_strict = true)
        case self
        when Oo1
            { "oo1": value }
        when Oo2
            { "oo2": value }
        when Oo3
            { "oo3": value.serialize }
          else
            T.absurd(self)
        end
    end

    sig { params(hash: T::Hash[String, T.untyped]).returns(Oo) }
    def self.from_hash(hash)
      if hash["oo1"] then
        return Oo1.new((PbHelper::withDefault(hash["oo1"], 0)))
      end
      if hash["oo2"] then
        return Oo2.new((PbHelper::withDefault(hash["oo2"], false)))
      end
      if hash["oo3"] then
        return Oo3.new(SimplePb::Colour.deserialize(PbHelper::withDefault(hash["oo3"], "RED")))
      end
      
      raise "Expected one of, but none were set"
    end

    
    class Oo1
      include Oo
      extend T::Sig

      sig { params(value: Integer).void }
      def initialize(value)
        @value = T.let(value, Integer)
      end

      sig { returns(String) }
      def to_s
        value.to_s
      end

      sig { params(other: T.untyped).returns(T::Boolean) }
      def ==(other)
        self.class == other.class &&
          @value == other.value
      end

      sig { returns(Integer) }
      attr_reader :value
    end
    
    class Oo2
      include Oo
      extend T::Sig

      sig { params(value: T::Boolean).void }
      def initialize(value)
        @value = T.let(value, T::Boolean)
      end

      sig { returns(String) }
      def to_s
        value.to_s
      end

      sig { params(other: T.untyped).returns(T::Boolean) }
      def ==(other)
        self.class == other.class &&
          @value == other.value
      end

      sig { returns(T::Boolean) }
      attr_reader :value
    end
    
    class Oo3
      include Oo
      extend T::Sig

      sig { params(value: SimplePb::Colour).void }
      def initialize(value)
        @value = T.let(value, SimplePb::Colour)
      end

      sig { returns(String) }
      def to_s
        value.to_s
      end

      sig { params(other: T.untyped).returns(T::Boolean) }
      def ==(other)
        self.class == other.class &&
          @value == other.value
      end

      sig { returns(SimplePb::Colour) }
      attr_reader :value
    end
    
  end

  sig { returns(String) }
  def to_json
    serialize.to_json
  end

  sig { params(_strict: T::Boolean).returns(T::Hash[String, T.untyped]) }
  def serialize(_strict = true)
    serialize_result = { 
      "s": s.serialize,
      "ss": ss.map(&:serialize),
      "optionalS": optional_s&.serialize,
      "colour": colour.serialize,
      "colours": colours.map(&:serialize),
      "optionalColour": optional_colour&.serialize,
      "intField": int_field,
      "intFields": int_fields,
      "optionalIntField": optional_int_field,
      "int64Field": int64_field.to_s,
      "int64Fields": int64_fields.map(&:to_s),
      "optionalInt64Field": optional_int64_field&.to_s,
      "timestampField": timestamp_field.iso8601,
      "timestampFields": timestamp_fields.map(&:iso8601),
      "optionalTimestampField": optional_timestamp_field&.iso8601,
    }
    serialize_result = serialize_result.merge(oo.serialize )
    serialize_result
  end

  sig { params(contents: String).returns(SimplePb::Foo) }
  def self.decode_json(contents)
    json_obj = JSON.parse(contents)
    from_hash(json_obj)
  end

  sig { params(hash: T::Hash[String, T.untyped]).returns(SimplePb::Foo) }
  def self.from_hash(hash)
    new(
      s: SimplePb::Simple.from_hash(PbHelper::withDefault(hash["s"], nil)),
      ss: PbHelper::withDefault(hash["ss"], []).map{SimplePb::Simple.from_hash(_1)},
      optional_s: PbHelper::mapNil(hash["optionalS"]) { SimplePb::Simple.from_hash(hash["optionalS"]) },
      colour: SimplePb::Colour.deserialize(PbHelper::withDefault(hash["colour"], "RED")),
      colours: PbHelper::withDefault(hash["colours"], []).map{SimplePb::Colour.deserialize(_1)},
      optional_colour: PbHelper::mapNil(hash["optionalColour"]) { SimplePb::Colour.deserialize(hash["optionalColour"]) },
      int_field: (PbHelper::withDefault(hash["intField"], 0)),
      int_fields: PbHelper::withDefault(hash["intFields"], []).map{(_1)},
      optional_int_field: PbHelper::mapNil(hash["optionalIntField"]) { (hash["optionalIntField"]) },
      int64_field: Integer(PbHelper::withDefault(hash["int64Field"], 0)),
      int64_fields: PbHelper::withDefault(hash["int64Fields"], []).map{Integer(_1)},
      optional_int64_field: PbHelper::mapNil(hash["optionalInt64Field"]) { Integer(hash["optionalInt64Field"]) },
      timestamp_field: Time.iso8601(PbHelper::withDefault(hash["timestampField"], "1970-01-01T00:00:00Z")),
      timestamp_fields: PbHelper::withDefault(hash["timestampFields"], []).map{Time.iso8601(_1)},
      optional_timestamp_field: PbHelper::mapNil(hash["optionalTimestampField"]) { Time.iso8601(hash["optionalTimestampField"]) },
      oo: Oo.from_hash(hash)
    )
  end
end

